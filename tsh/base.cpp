#include "base.h"
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <wait.h>

/*unix_error - unix-style error routine*/
void unix_error(char *msg){
    fprintf(stdout, "%s : %s\n", msg, strerror(errno));
    exit(1);
}
void posix_error(int code, char *msg) /*posix-style error*/
{
    fprintf(stderr, "%s: %s\n", msg, strerror(code));
    exit(0);
}

void app_error(char *msg)/*application error*/
{
    fprintf(stderr, "%s\n", msg);
    exit(0);
}
/*end error func*/

void dns_error(char *msg){
    fprintf(stderr, "%s\n", msg);
    exit(0);
}


void usage(void)
{
    printf("Usage: shell [-hvp]\n");
    printf("   -h   print this message\n");
    printf("   -v   print additional diagnostic information\n");
    printf("   -p   do not emit a command prompt\n");
    exit(1);
}

/*********************************************
 * Wrappers for Unix process control functions
 ********************************************/
pid_t Fork()
{
    pid_t pid;
    if((pid = fork()) < 0)unix_error("Fork error");
    return pid;
}

void Execve(const char*filename, char* const argv[], char *const envp[])
{
    if(execve(filename, argv, envp) < 0)unix_error("Execve error");
}

pid_t Wait(int *status){
    pid_t pid;

    if((pid = wait(status)) < 0)unix_error("Wait error");
}


pid_t Waitpid(pid_t pid, int *iptr, int options)
{
    pid_t retpid;

    if((retpid = waitpid(pid, iptr, options)) < 0)unix_error("Waitpid error");
    return (retpid);
}

void Kill(pid_t pid, int signum){
    int rc;
    if((rc = kill(pid, signum)) < 0)unix_error("Kill error");
}

void Pause()
{
    (void)pause();
    return;
}

unsigned int Sleep(unsigned int secs){
    return sleep(secs);
}

unsigned int Alarm(unsigned int seconds){
    return alarm(seconds);
}

void Setpgid(pid_t pid, pid_t pgid){
    int rc;

    if((rc = setpgid(pid, pgid)) < 0)unix_error("Setpgid error");
    return;
}
pid_t Getpgrp(void){
    return getpgrp();
}

int Dup2(int fd1, int fd2){
    int rc;
    if((rc = dup2(fd1, fd2)) < 0)unix_error("Dup2 error");
    return rc;
}

int Open(const char *pathname, int flags, mode_t mode)
{
    int rc;

    if((rc = open(pathname, flags, mode)) < 0)unix_error("Open error");
    return rc;
}

/*wrapper function end*/